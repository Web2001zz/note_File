# Vue

## Vue是什么？

## MVVM与MVC的区别
  - MVVM
    - M model 数据模型层
    - V view 视图层
    - VM ViewModel 视图模型层
      - MVVM模式下，model的数据可以通过vm展示到view视图层上
      - view视图层上修改数据也可以通过vm来修改model层上的数据
  - MVC
    - M model
    - V view 
    - C controller 控制层
      - MVC模式下，会通过控制层操作model数据展示到view视图层上
  - 值得一提的是Vue其实算是单项数据流，但其拥有v-model指令完成了双向数据绑定的方法使用了MVVM模式

## react与vue的区别
  - react使用的是jsx语法 而vue使用的是template模板
  - react使用的是单项数据流，vue也是单项数据流但其具有双向数据绑定
  - react没有指令，vue有指令
  - 更新方式不一样，diff算法也不一样
  - vue的很多语法（如通信方式，计算属性）是react不具有的

## Vue中组件有几种传参方式？
  - 1.props：
    - 一般用于父向子传参 父组件设置给子组件的数据会储存到$attrs里
    - props可以用字符串接收，也可以使用一个对象接收，用于对接收回来的数据做些许限制
    - 当props接收数据后，其数据不会存在于$attrs中
    
  - 2.自定义事件
    - 一般用于子向父传参，其原理是父组件在子组件的实例对象上绑定自定义事件，事件在子组件内部传参调用，最终父组件会接收到子组件内传过来的参数
    - 父组件绑定后，子组件this.$emit("handle",funcion(调用并传入的参数))
    
  - 3.全局事件总线
    
    - 可以在所有组件传参，其本身就是自定义事件方法的一种延伸，其原理便是在Vue实例对象的原型上设置公共属性并绑定事件，所有组件都可以直接访问到其事件并调用
    - 在实例对象上做绑定事件:Vue.prototype.$bus = this(写在实例对象内)
    - 其他组件使用:this.$bus.$on
    
  - 4.provide/inject
       
    - 用于爷孙组件传参，
    - 祖辈组件在provide里声明，其下所有组件都可以使用inject接收
    - inject接收时使用数组，值为一个个字符串，"祖辈定义的变量名"
    
  - 5.$attrs/$listeners
    - 同样用于父向子传参
    - $attrs储存未被props接收的参数
    - $listeners储存的是函数  
    
  - 6.$parent
    
    - 可以获取到父组件的实例对象
    - $children，可以获取到所有子组件的实例对象，是一个数组
    - $root，可以获取到根组件的实例对象
    - $refs，将ref添加到组件身上，也可以获取到他的组件对象
    
  - 7.v-model与.sync操作符
    
    - v-model与.sync都是可以设置响应式数据的传参方式，不同的是v-model主要用于传参给表单，.sync则传给一般组件
    
    - v-modle传给子组件的时候，最开始传的是变量的值，子组件接收时变量名为value
    
    - 子组件可以通过model属性接收，并将其变量重新命名
    
    - ``` vue
      //子组件操作
      medol:{
      	prop:"重命名变量名"，
      	event:"重命名方法名"
      }
      ```
    
- 8.Vuex 详情见Vuex

- 9.v-slot插槽

  - 用于给子组件传参，通常会带标签
  - 插槽传参详见 v-slot

- 10.pubsub发布订阅

  - 不常用，提一嘴





## 如何理解Vuex
  - Vuex是集中式管理数据的插件工具，会为vue全局暴露一个对象store
  - store中也存在几个对象，分别是：
    - state 储存状态数据
    - mutations 直接修改状态数据的方法，一般是将同步代码写入
    - actions 用于间接修改state的数据，一般写入异步代码
    - getter 相当于vue中的computed属性，一般设置的是获取state数据


## VueRouter的原理
  - 监视


## Vue中的$nextTick原理
  - Vue中的this.$nextTick会在父级函数的同步代码执行完毕后立刻调用的异步函数（详情参考事件轮询微任务宏任务）
  - $nextTick都会开启一个then方法执行其内部的异步代码，他会将所有的$nextTick的回调函数添加到一个数组里
  - 数组内的回调函数会遍历调用，调用过一次后便会退出then的执行队列，就算有多个$nextTick也只会开启一个then执行队列
  - 为什么在修改页面数据后nextTick会先一步then方法调用？
    - 因为修改自身数据是同步执行的，而修改渲染到页面上的数据（响应式）是异步执行，执行时也会开启一个then的执行队列
    - $nextTick就会先行加入到其队列中，所以比后来的自开启then的执行函数要快
    - 当没有修改页面数据的时候，then和$nextTick会根据代码顺序执行异步代码



## Vue中的双向数据流
  - Vue实际上依然是单项数据流，但vue拥有v-model指令从而完成双向数据流绑定
  - v-model指令做了什么？
    - 给input表单设置v-model，会进行两步操作
      - 首先给该表单设置的value为v-model绑定的值
      - 其次为表单绑定了input事件，当修改表单时便会触发input事件
        - input事件中捕捉到当前元素的状态，并将当前表单的值重新设置给绑定到表单上的data数据
        - 从而完成了在页面上修改数据并修改原数据还能更新视图的双向数据绑定


## Vue中的生命周期
  - Vue中的生命周期分为三个阶段，每个阶段都有着生命周期钩子函数：
    - 初始化阶段
      - beforeCreate() 在初始化生命周期之后，数据代理之前执行
      - Created() 完成数据代理、数据劫持、设置数据响应式之后执行
        - created阶段也可以进行发送请求等操作
      - beforeMounted() 将vm实例挂载到el元素上之后执行
      - Mounted() 页面上所有元素全部挂载完毕后执行
        - 通常情况下，我们会在mounted函数内进行发送请求、绑定事件、设置定时器等操作
    - 更新阶段（当用户更新数据后进入）
      - beforeUpdate() 判断数据是否改变后触发
      - updated() 数据更新后，会创建一个新的虚拟dom树替换或复用旧的虚拟dom树更新界面后触发
    - 卸载阶段（当前组件确定卸载时进入）
      - beforeDestroy() 进入卸载阶段触发，之后会开始卸载watchers，子组件、事件监听等
        - 通常情况下我们会在这个钩子函数内进行取消计时器、解绑事件等操作
      - destroyed() 整个组件全部卸载完毕后触发

# Vue源码解析

## 数据代理
- 所谓数据代理就是将data数据代理到vue的实例对象上，将来可以直接通过this.data访问到数据
- 数据代理步骤
  - 将传入的_data数据保存到this.data身上
  - 使用Object.keys方法data中所有的属性装进数组并遍历设置
  - 所有属性都会使用Object.defineProperty方法重新设置其属性描述符
    - 当触发get方法的时候，访问this._data的值就相当于访问原_data的数据
    - 当触发set方法的时候，设置this._data的值就相当于设置原_data的数据
  - 途中会再次递归调用该方法确保所有data数据（包括其对象内部数据）都会进行数据代理



## 数据劫持
  - 数据劫持会将所有的data数据进行重新定义，定义成响应式
  - 大体方法同数据代理，也是使用Object.defineProperty方法重新定义set和get方法
  - 但是在设置阶段，data的数据并不能与set和get共存，因此使用了闭包的方式为get方法保存了data的原数据
  - 当访问到数据时，get方法中会通过dep方法建立dep和watcher的联系
  - 当设置到数据时，set方法中会通过dep方法通知所有的watcher更新用户界面
  - 也会使用递归调用保证其所有数据都能重新定义为响应式


## 模板解析
  - 会解析模板中的差值语法、指令、绑定事件并处理
  - 数据劫持阶段、会将传入的元素节点转换为文档碎片、取出当前节点所有子节点遍历执行以下判断：
    - 首先判断是元素节点还是文本节点
      - 元素节点
        - 取出当前元素的所有属性遍历判断是否含有指令（V-）
          - 如果是绑定事件类指令则
            - 判断事件类型，并执行相应的回调函数，同时回调函数会通过bind方法强制改变this指向vm
          - 如果是正常的指令语法则
            - 执行相应的指令
      - 文本节点
        - 使用正则判断其文本节点是否含有插值语法
          - 使用插值语法会提取其内容展示对应数据，给元素设置textContext，值为表达式对应的值
  - 编译完成后将模板添加到页面中生效
  - 将来用户更新data数据时，会先触发数据代理，修改原数据上的值
  - 再触发数据劫持的set方法，通过dep.notify方法通知所有当前保存的watcher去更新用户界面，从而达到响应式
